
\chapter{Introduction to Agda}
Agda is a dependently typed functional programming language. Its typesystem is so powerful that it can be used as a proof assistant. Checking if a function is correct can be done by successfully compiling the file containing it.

\section{Inductive datatypes}
Datatypes can be defined inductively. For example, the type for natural numbers has a base case zero and an inductive case for the successor. In Agda, these two cases are defined as constructors:
\begin{agda}
data ℕ : Set where
  zero : ℕ
  suc  : ℕ → ℕ
\end{agda}
\texttt{zero} is the constructor for the base case and \texttt{suc} receives a number as paramether and constructs its successor. For example, one is defined as \texttt{suc zero}, two is defined as \texttt{suc (suc zero)} and three is defined as \texttt{suc (suc (suc zero))}.\\
Writing big numbers with this notation can be tedious, so Agda provides a shortcut for built-in types such as numbers:
\begin{agda}
{-# BUILTIN NATURAL ℕ #-}

y : ℕ
y = 123
\end{agda}
\section{Functions}
We can define the addition operation recursively:
\begin{agda}
_+_ : ℕ → ℕ → ℕ
zero + n = n
(suc m) + n = suc (m + n)
\end{agda}
Here \texttt{\_+\_} is the name of the function. It receives two natural numbers as parameters and produces a natural number. Underscores are used to define infix notation and indicate where the arguments should be placed. In this case, the sum of two numbers \texttt{n}, \texttt{m}, can be written as \texttt{n + m}, which is equivalent to not using infix notation at all \texttt{(\_+\_ n m)}.\\
The definition uses pattern matching to match all possible constructors for the first argument. It has a base case for \texttt{zero} and an inductive case for the successor. In the first case, adding \texttt{zero} to a number \texttt{n} returns simply \texttt{n}. In the second case, adding \texttt{suc m} to \texttt{n} returns the successor of the sum of the two smaller ones \texttt{suc (m + n)}.\\ 
When defining functions, Agda performs termination checks. A function terminates correctly when the recursion is done on smaller arguments. 

\section{Induction}
Inductive datatypes are somehow related to the (structural) induction principle. Proving a property for an inductive datatype can be done by showing that the property holds for the base cases and then showing it holds for the inductive cases, eventually using the inductive hypothesis.\\
In Agda, the induction hypothesis is generated by recursion.\\
Here is an example which proves the right identity of addition:
\begin{agda}
+-identityʳ : ∀ (m : ℕ) → m + zero ≡ m
+-identityʳ zero = refl
+-identityʳ (suc m) with +-identityʳ m
... | IH = cong suc IH
\end{agda}
For the base case we have \texttt{m = zero} and so the goal requires a proof for \texttt{zero + zero ≡ zero}. By definition of addition, \texttt{zero + zero = zero} and we conclude \texttt{zero ≡ zero}. For the inductive case, we need to prove \texttt{suc (m + zero) ≡ suc m}. The \texttt{with} command evaluates the induction hypothesis using recursion on \texttt{m}. The value of \texttt{IH} is \texttt{m + zero ≡ m}. We conclude the case using the congruence property of equality, which states that if two arguments are equal, then equality is preserved after applying the same function to both:
\begin{agda}
cong : ∀{A C : Set} {a : A} {b : A} 
  (f : A → C) 
  → a ≡ b 
  → f a ≡ f b
cong f refl = refl
\end{agda}
The proof for identity can be simplified with the \texttt{rewrite} command. It takes an equality argument like $a \equiv b$ and it internally instructs Agda to rewrite $b$ where it finds $a$. The rewriting step is done only once, in order to avoid infinitely growing rewrites:
\begin{agda}
+-identityʳ' : ∀ (m : ℕ) → m + zero ≡ m
+-identityʳ' zero = refl
+-identityʳ' (suc m) with +-identityʳ m
... | IH rewrite IH = refl
\end{agda}
The inductive case requires a proof for \texttt{suc (m + zero) ≡ suc m}.\\
Using the \texttt{rewrite} command on the induction hypothesis (same as the previous one: \texttt{m + zero ≡ m}), Agda internally updates the left side of the goal from \texttt{suc (m + zero)} to \texttt{suc (m)}. The required proof becomes \texttt{suc m ≡ suc m} which is immediate.\\
For these proofs, we actually used another datatype: the equality datatype. It is a dependent datatype, meaning that it depends on a concrete value:
\begin{agda}
data _≡_ {A : Set} (x : A) : A → Set where
  refl : x ≡ x
\end{agda}
\section{Dependent datatypes}
Dependent datatypes are types depending on one or more values. For example, the type for finite-size vectors can be defined as a dependent type:
\begin{agda}
data Vec (A : Set) : ℕ → Set where
    []  : Vec A zero
    _∷_ : ∀ {n} (x : A) (xs : Vec A n) → Vec A (suc n)
\end{agda}
It depends on a natural number, the size of the vector. The \texttt{[]} constructor builds a vector of size \texttt{zero}. The \texttt{\_∷\_} constructor takes two parameters, an element of type \texttt{A} and a vector of size \texttt{n}, and builds a vector of size \texttt{1 + n}.\\
Here is an example of a vector containing two natural numbers:
\begin{agda}
x : Vec ℕ 2
x = 1 ∷ 3 ∷ []
\end{agda}
We can also define the type for finite numbers \texttt{Fin n}:
\begin{agda}
data Fin : ℕ → Set where
  zero : {n : ℕ} → Fin (suc n)
  suc  : {n : ℕ} (i : Fin n) → Fin (suc n)
\end{agda}
This means that a value of type \texttt{Fin n} can only be a number between \texttt{zero} and \texttt{n - 1}.\\
For example, only the numbers \texttt{0} and \texttt{1} can be of type \texttt{Fin 2}:
\begin{agda}
a : Fin 2
a = zero

b : Fin 2
b = suc zero
\end{agda}
Saying that \texttt{2} is of type \texttt{Fin 2} is wrong and Agda rejects it:
\begin{agda}
c : Fin 2
c = suc (suc zero)
-- Error :
-- (suc _n_34) != zero of type ℕ
-- when checking that the expression zero has type Fin 0
\end{agda}


Using \texttt{Fin} and \texttt{Vec} types, we can define a total function for accessing a value at an index in a vector:
\begin{agda}
lookup : ∀ {n} → Vec A n → Fin n → A
lookup (x ∷ xs) zero    = x
lookup (x ∷ xs) (suc i) = lookup xs i
\end{agda}
Since lookup is total, there cannot be any run-time error while accessing a value at a given index (e.g. IndexOutOfBoundsException in Java). If we were to write \texttt{x = lookup (1 ∷ []) (suc zero)}, the type checker would raise an error as the vector is of type \texttt{Vec ℕ 1}, whereas the index is of type \texttt{Fin 2}.

\subsection{Propositions as types}
By taking advantage of dependent datatypes, logical propositions can be defined as types. For example, the following type can be used to constructively build a proposition stating that a number is Even:
\begin{agda}
data Even : ℕ → Set where
  zero : Even zero
  next : ∀{n : ℕ}
    → Even n
    → Even (suc (suc n))
\end{agda}
We say that \texttt{0} is even and adding \texttt{2} to an even number constructs another even number. We can define a similar proposition for Odd numbers where the base case is \texttt{1} instead of \texttt{0}: 
\begin{agda}
data Odd : ℕ → Set where
  one : Odd (suc zero)
  next : ∀{n : ℕ}
    → Odd n
    → Odd (suc (suc n))
\end{agda}
Using these two propositions, we can prove that for an arbitrary number \texttt{n}, \texttt{Even n} implies \texttt{Odd (suc n)}:
\begin{agda}
even⇒suc-odd : ∀{x : ℕ} 
  → Even x
    -----------
  → Odd (suc x)
even⇒suc-odd zero = one
even⇒suc-odd (next a) = next (even⇒suc-odd a)
\end{agda}
Here we used the function type as an implication.\\
We can also say that \texttt{Odd n} implies \texttt{Even (suc n)}:
\begin{agda}
odd⇒suc-even : ∀{x : ℕ} → Odd x → Even (suc x)
odd⇒suc-even one = next zero
odd⇒suc-even (next a) = next (odd⇒suc-even a)
\end{agda}
We can also define connectives as datatypes. For example, conjunction can be defined as the product type (also interpretable as a Pair) and disjunction can be defined as the sum type (also referred to as the Either type):
\begin{agda}
data _×_ (A B : Set) : Set where
  ⟨_,_⟩ : A → B → A × B
  
data _⊎_ (A B : Set) : Set where
  inj₁ : A → A ⊎ B
  inj₂ : B → A ⊎ B
\end{agda}
For example, we can prove that every natural number is even or odd:
\begin{agda}
ℕ-Even-or-Odd : ∀(x : ℕ) → Even x ⊎ Odd x
ℕ-Even-or-Odd zero = inj₁ zero
ℕ-Even-or-Odd (suc x) with ℕ-Even-or-Odd x
... | inj₁ ev = inj₂ (even⇒suc-odd ev)
... | inj₂ od = inj₁ (odd⇒suc-even od)
\end{agda}

Regarding true and false, we can still be constructive. The type for truth is the unit type, with a single constructor \texttt{tt}. On the other hand, false is the empty type, without any constructor: 
\begin{agda}
data ⊤ : Set where
  tt : ⊤

data ⊥ : Set where
-- no constructors
\end{agda}

False implies anything. In fact, Agda automatically closes the case as no constructor pattern that can be matched:
\begin{agda}
⊥-elim : ∀ {A : Set}
  → ⊥
  → A
⊥-elim ()
\end{agda}
Negation is a function which takes a type \texttt{A} and creates a function which takes an argument of the type \texttt{A} and produces the empty type:
\begin{agda}
¬_ : Set → Set
¬ A = A → ⊥
\end{agda}
Given a proposition \texttt{¬ A}, if we provide an argument of type \texttt{A}, we are able to construct the empty type, which is absurd as empty has no constructors. Therefore, we could conclude anything using \texttt{⊥-elim}. For example, we can show that if a number is even, then it is not odd. As a consequence, we can conclude that no natural number is both even and odd:
\begin{agda}
even⇒¬odd : ∀{x : ℕ} → Even x → ¬ Odd x
even⇒¬odd zero = λ ()
even⇒¬odd (next ev) (next od) = ⊥-elim((even⇒¬odd ev) od)

ℕ-not-both-even-odd : ∀{x : ℕ} → ¬ (Even x × Odd x)
ℕ-not-both-even-odd ⟨ ev , od ⟩ = ⊥-elim (even⇒¬odd ev od)
\end{agda}

The ``if and only if'' proposition is a record with two fields, each representing one direction of the implications:
\begin{agda}
record _⇔_ (A B : Set) : Set where
  field
    to   : A → B
    from : B → A
\end{agda}

Isomorphism between types is defined similarly to ``if and only if'', with two additional fields which provide the proofs about the identity of compositions:
\begin{agda}
record _≃_ (A B : Set) : Set where
  field
    to   : A → B
    from : B → A
    from∘to : ∀ (x : A) → from (to x) ≡ x
    to∘from : ∀ (y : B) → to (from y) ≡ y
\end{agda}

Propositional types provide constructive evidence why propositions hold, but we can also define propositions using the \texttt{Bool} type and define connectives as functions:
\begin{agda}
data Bool : Set where
  true  : Bool
  false : Bool
  
_∧_ : Bool → Bool → Bool
true  ∧ true  = true
_     ∧ _     = false

_∨_ : Bool → Bool → Bool
true  ∨ _      = true
_     ∨ true   = true
false ∨ false  = false

not : Bool → Bool
not true  = false
not false = true
\end{agda}
The \texttt{Bool} type can be mapped to the relative \texttt{⊤} and \texttt{⊥} propositions:
\begin{agda}
T : Bool → Set
T true   =  ⊤
T false  =  ⊥
\end{agda}
A function that produces boolean values can include both true and false cases, but it provides less information than the propositional types approach. On the other hand, the latter must be defined manually by providing a construction (in fact, we cannot prove some laws like the ``excluded middle law'' \texttt{∀\{A : Set\} → A ⊎ ¬ A}).\\
Both benefits can be included in one type, the decidable type. It combines the functional aspect where true and false can be decided, and it also concretely provides constructive proofs:
\begin{agda}
data Dec (A : Set) : Set where
  yes :   A → Dec A
  no  : ¬ A → Dec A
\end{agda}
For example, for any natural number \texttt{n}, we can decide whether the proposition \texttt{Even n} holds or not:
\begin{agda}
Even? : ∀(x : ℕ) → Dec (Even x)
Even? x with ℕ-Even-or-Odd x
... | inj₁ xEven = yes xEven
... | inj₂ xOdd = no (λ xEven → ℕ-not-both-even-odd ⟨ xEven , xOdd ⟩)
\end{agda}

We use the property \texttt{ℕ-Even-or-Odd} which states that a number \texttt{x} is even or odd (the case where both propositions hold is not excluded).\\
If \texttt{x} is even, we conclude with \texttt{yes} by providing the same proof determined by the lemma.\\
Otherwise, when \texttt{x} is odd, we conclude that \texttt{x} is not even. In fact, we show that assuming \texttt{x} is also even allows us to construct the empty type by applying \texttt{ℕ-not-both-even-odd}.  

\subsection{Vec, Fin and Subset properties}
In this section, we define the \texttt{Subset} type which we use later. A Subset of size $n$ is a vector of size $n$ containing Bool values.
\begin{agda}
Subset : ℕ → Set
Subset n = Vec Bool n
\end{agda}
An element \texttt{i : Fin n} is in the subset if the value at index \texttt{i} in the vector is \texttt{true}. 
\begin{agda}
_∈_ : ∀{n} → (p : Fin n) → (ss : Subset n) → Set
p ∈ ss = T(lookup ss p)

_∉_ : ∀{n} → (p : Fin n) → (ss : Subset n) → Set
p ∉ ss = ¬ T(lookup ss p)
\end{agda}
We can decide whether or not an element belongs to a subset: 
\begin{agda}
_∈?_ : ∀{n} → (p : Fin n) → (ss : Subset n) → Dec (p ∈ ss)
zero  ∈? (false ∷ z) = no (λ z → z)
zero  ∈? (true ∷ z)  = yes tt
suc p ∈? (x ∷ z)     = p ∈? z
\end{agda}
A \texttt{Fin n} value can be transformed into a natural number:
\begin{agda}
toℕ : ∀ {n} → Fin n → ℕ
toℕ zero    = 0
toℕ (suc i) = suc (toℕ i)
\end{agda}
A \texttt{Fin m} value can be raised arbitrarily into \texttt{Fin (n + m)}:
\begin{agda}
raise : ∀ {m} n → Fin m → Fin (n ℕ.+ m)
raise zero    i = i
raise (suc n) i = suc (raise n i)

\end{agda}
A \texttt{Fin m} value can also be injected into \texttt{Fin (m + n)}:
\begin{agda}
inject+ : ∀ {m} n → Fin m → Fin (m ℕ.+ n)
inject+ n zero    = zero
inject+ n (suc i) = suc (inject+ n i)
\end{agda}
Given a \texttt{Fin (n + m)} value, we can split the sum generating either \texttt{Fin n} or \texttt{Fin m}:
\begin{agda}
splitAt : ∀ m {n} → Fin (m + n) → Fin m ⊎ Fin n
splitAt zero    i        = inj₂ i
splitAt (suc m) fzero    = inj₁ fzero
splitAt (suc m) (fsuc i) = Data.Sum.map fsuc (λ x → x) (splitAt m i)
\end{agda}
And here are two proofs about raising, injecting and splitting:
\begin{agda}
splitAt-raise : ∀ m n i → splitAt m (raise {n} m i) ≡ inj₂ i
splitAt-raise zero    n i = refl
splitAt-raise (suc m) n i 
  rewrite splitAt-raise m n i = refl

splitAt-inject+ : ∀ m n i → splitAt m (inject+ n i) ≡ inj₁ i
splitAt-inject+ (suc m) n fzero = refl
splitAt-inject+ (suc m) n (fsuc i) 
  rewrite splitAt-inject+ m n i = refl
\end{agda}