\chapter{Conclusion}
We formalized regular expressions and NFAs and proved the correctness of two different approaches for solving the matching problem. We showed that finite-state automata are closed under union, concatenation, and star operations and that the regular expressions language class is a subset of the NFAs language class. One further development could be to prove the inverse transformation. Our development ended with the formalization of the pumping lemma, which we used to prove the limits of these computation models. There is also a pumping lemma for the immediate superset of regular languages, context-free languages. The formalization of this class of languages could also be a future extension of the project.\\

An important conclusion that can be drawn from all this work is that sophisticated type-systems can be used as powerful tools that enforce writing correct code, to such an extent that compilers can be turned into theorem provers. Agda is a clear example of this.\\
On a proof assistant level, the constructive evidence approach used in Agda helps understand the flow of proofs flawlessly. In some cases, though, this also requires to provide constructions for many other seemingly obvious properties, which other theorem provers solve automatically. However, the Agda standard library is immense and it exposes plenty of well-known principles and properties. For instance, the file \texttt{Data.Nat.Properties} contains many properties about natural numbers and counts \texttt{2000+} lines of proofs.\\
When firstly approaching Agda, the learning curve can be very steep, but with a solid base in functional programming and Haskell, it becomes straightforward.